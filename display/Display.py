import curses

from display.Drawer import Drawer
from display.Pixel import Pixel
from display.ANSIColour import ANSIColour
from typing import Iterable

class Display:
    """
    The primary class that draws onto and interacts with the terminal through
    the `curses` library. Designed to be called within the `wrapper` function.
    Specifically, maintains a pad that draws onto the main window which can be
    updated using `Pixel`s generated by objects like `Drawer`s.
    """

    ### CONSTANTS

    REFRESH_RATE_HZ = 20
    DEBUG_HEIGHT    = 7 # arbitrary
    DEBUG_WIDTH     = 30 


    ### INITIALISATION

    def __init__(self,
                 stdscr: curses.window,
                 refreshRate: int = REFRESH_RATE_HZ,
                 useNatural: bool = True,
                 doDebug: bool = False):
        self.stdscr = stdscr
        self.height, self.width = stdscr.getmaxyx()
        self.refreshRate = refreshRate
        
        self.useNatural = useNatural

        self.resetStats()

        self.doDebug = doDebug
        self.debugWindow = curses.newwin(self.DEBUG_HEIGHT, self.DEBUG_WIDTH, 0, 0)

        ## CONFIG

        curses.curs_set(0)
        self._initColorResult = self._initColors() # used in debug
        self._colorPairs = dict()
        self._nextUnusedPair = 8

    def resetStats(self):
        """
        Resets all the stored statistics (e.g. number of refreshes since init) to their defaults.
        """
        self.numRefreshes = 0     # number of window refreshes
        self.pixelsDrawn = 0      # number of pixels drawn
        self.debugMessage = "Hello, world!"

    def _initColors(self) -> bool:
        """
        Initialises all possible `ANSIColour` values in `curses` (codes 16-231). Called once when
        `Display` is initialised. Returns true if the colours were successfully changed.
        """
        if not curses.can_change_color():
            return False

        for r in range(6):
            for g in range(6):
                for b in range(6):
                    m = 36*r + 6*g + b + 16
                    curses.init_color(m, 200*r, 200*g, 200*b)
        
        return True

    def getColorPair(self,
                      fg: ANSIColour = Pixel.FG_DEFAULT,
                      bg: ANSIColour = Pixel.BG_DEFAULT) -> int:
        """
        Retrieves the color code corresponding to a given FG-BG pair. If none exists, assigns an unused
        code to it. Returns 0 if there are no available codes (e.g. COLOR_PAIRS == 8)
        """
        if self._nextUnusedPair >= curses.COLOR_PAIRS:
            return 0
        codeHash = (fg.getCode(), bg.getCode())
        if codeHash in self._colorPairs:
            return self._colorPairs[codeHash]

        self._colorPairs[codeHash] = self._nextUnusedPair
        curses.init_pair(self._nextUnusedPair, fg.getCode(), bg.getCode())
        self._nextUnusedPair += 1
        return self._nextUnusedPair - 1


    ### DRAWING

    def drawPixel(self,
                  pixel: Pixel,
                  isBatched = True):
        """
        Draws a `Pixel` onto the screen. If `isBatched` is False, refreshes the screen after drawing.
        If `useNatural` is True (default), converts from natural coordinate conventions (bottom-left origin, +y up)
        instead of using curses conventions (top-right origin, +y down).
        """
        x,y = pixel.position
        if self.useNatural:
            y = self.height - y

        colorPair = self.getColorPair(pixel.fg, pixel.bg)
        self.stdscr.addch(
            y,x,pixel.ch,curses.color_pair(colorPair)
        )

        if not isBatched:
            self.refresh()

    def draw(self, 
             *objs: Drawer | Iterable[Pixel] | Pixel,
             isBatched = False):
        """
        Draws one or more `Drawer` instances onto the screen in order of appearance. If `isBatched` is False (default),
        refreshes the screen after drawing.
        """
        for o in objs:
            if type(o) == Drawer:
                pixelIter = o.genPixels()
            elif type(o) == Iterable[Pixel]:
                pixelIter = o
            elif type(o) == Pixel:
                self.drawPixel(o, isBatched=True)
                continue
            else:
                raise ValueError("Display.draw: invalid argument type - " + str(type(o)))
            
            for pixel in pixelIter:
                self.drawPixel(pixel, isBatched=True)
        
        if not isBatched:
            self.refresh()

    def clearAll(self):
        """
        Clears the standard screen and deletes every stored object from the internal structures.
        """
        self.stdscr.clear()


    def refresh(self):
        """
        Refreshes the screen, drawing all accumulated updates. Also updates internal stats.
        """
        self.numRefreshes += 1
        self.stdscr.noutrefresh()
        if self.doDebug:
            self.drawDebug()
            self.debugWindow.noutrefresh()
        curses.doupdate()


    ### DEBUG
    
    def setDebugMessage(self, msg):
        """
        Sets the displayed message in the debug window to `msg`, cut off at `DEBUG_WIDTH` characters.
        """
        self.debugMessage = str(msg)

    def drawDebug(self,
                  isBatched=True):
        """
        Draws the debug window, a window positioned on the top left that displays program
        stats. If `isBatched` is False, refreshes the screen after drawing.
        """

        colSuccSym = "C" if self._initColorResult else "c"
        naturalSym = "N" if self.useNatural else "n"
        flags = colSuccSym + naturalSym

        self.debugWindow.addnstr(
            0, 0, f"## DEBUG ## ({flags})", self.DEBUG_WIDTH, curses.A_REVERSE
        )
        self.debugWindow.addnstr(
            1, 0, f"{self.width}x{self.height}", self.DEBUG_WIDTH, curses.A_REVERSE
        )
        self.debugWindow.addnstr(
            2, 0, f"numRefreshes: {self.numRefreshes}", self.DEBUG_WIDTH, curses.A_REVERSE
        )
        self.debugWindow.addnstr(
            3, 0, f"pixelsDrawn: {self.pixelsDrawn}", self.DEBUG_WIDTH, curses.A_REVERSE
        )
        self.debugWindow.addnstr(
            4, 0, f"colorPairs: {self._nextUnusedPair}/{curses.COLOR_PAIRS} ({curses.COLORS})", self.DEBUG_WIDTH, curses.A_REVERSE
        )
        self.debugWindow.addnstr(
            5, 0, self.debugMessage, self.DEBUG_WIDTH, curses.A_REVERSE
        )
        if not isBatched:
            self.refresh()


